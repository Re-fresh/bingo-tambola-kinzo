// Lines containing System.out.xxxxx commented below can be uncommented 
// and be used to see how the program is working

// Importing Libraries
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Random;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicIntegerArray;
//-----
//-----
//-----
//-----


// Search class, moderator class uses linear_search and player class uses atomicLinearSearch
class search{
	public static int linear_search(int arr[], int value) {
		for(int i=0;i<arr.length;i++) {
			if(arr[i]==value) return i;
		}
		return -1;
	}
	public static int atomicLinearSearch(AtomicIntegerArray xyz, int value) {
		for(int i=0;i<xyz.length();i++) {
			if(xyz.get(i)==value) {return 1;}
		}
		return -1;
	}
}
//-----
//-----
//-----
//-----


// Checking for who is the winner
// I realized later that I could have managed without AtomicInteger/AtomicIntegerArray by using "static int" 
// instead, but since both achieved same I left it as it is
class universal{
	static AtomicInteger isThereAWinner = new AtomicInteger();			//default value is 0	
}
//-----
//-----
//-----
//-----


// Class READ, contains has_player_read AtomicIntegerArray, the value at any index can be either 0 or 1
class READ{
	public static AtomicIntegerArray has_player_read;
	READ(int y){	//Constructor, y is given as input and y = number_of_players
	if(READ.f.get()==0) { 		// f is a flag variable
		has_player_read = new AtomicIntegerArray(y);
		READ.f.set(1);
//		System.out.println(READ.has_player_read.toString());
	}}
	public static AtomicInteger f= new AtomicInteger();
//	public static AtomicIntegerArray has_player_read;
	public static void makeZero() {
		for(int i=0;i<has_player_read.length();i++) {
			has_player_read.getAndSet(i, 0);
		}
	
	}
}
//-----
//-----
//-----
//-----


// moderator class
class moderator implements Runnable{
	private static moderator mod_instance = new moderator();	// Used for SINGLETON design pattern
	
	// ArrayList containing numbers generated by Moderator, having length 10 and initial values are -99
	static ArrayList<Integer> arr = new ArrayList<>(Arrays.asList(-99,-99,-99,-99,-99,-99,-99,-99,-99,-99));
	
	private moderator(){		// CONSTRUCTOR is private
		System.out.println("Moderator Started");
	}
	
	public static moderator getInstance(){  // Used for SINGLETON design pattern
		return mod_instance;
	}

	public void run() {	
		Random r = new Random(); 
		for(int i=0;i<10;i++) {
			READ.makeZero();		// makes all values of has_player_read to 0
			arr.set(i, r.nextInt(51));
			System.out.println( i + ". Moderator generated " + arr.get(i));
			// this checks whether one of players didnt read the number generated by moderator yet
			int chk = search.atomicLinearSearch(READ.has_player_read, 0); 
			if(universal.isThereAWinner.get()>0){break;}		// if winner already there, moderator is stopped
			
			while(chk==1) {// Keeps running until all players have read the number generated by moderator
				try {Thread.sleep((new Random().nextInt(1200)+1100));} catch (InterruptedException e) {}
				chk = search.atomicLinearSearch(READ.has_player_read, 0); //chk is updated again
			}
			
			
		}
		System.out.println("Moderator stopped");
		System.out.println("Numbers generated by moderator: " + arr.toString());

		try {Thread.sleep(5000);} catch (InterruptedException e) {e.printStackTrace();}
		if(universal.isThereAWinner.get() ==0) { //if nobody wins 
			System.out.println("Nobody won"); 
			System.exit(0);}
	}
}
//-----
//-----
//-----
//-----


// design patter PROXY
class proxyModerator implements Runnable{
	moderator actualmod = moderator.getInstance(); //Singleton Design pattern
	public void run() {
		actualmod.run();
	}
	
}
// -----
//-----
//-----
//-----


class player implements Runnable{
	// max_length of scratch_card =3, -100 is added to list if generated no. by moderator is with the player
	ArrayList<Integer> scratch_card = new ArrayList<>();	
	
	//player cards 
	int[] p_arr = new int[10];
	int p_id;
	player(int n) {
	p_id = n;
	for(int i=0;i<10;i++) {
			p_arr[i] = (new Random()).nextInt(51);	//Random 10 cards having value b/w 0-50 are provided to player
		}
	System.out.println("Player " + p_id + ": " + Arrays.toString(p_arr));	
	}
	public void run() {
		for(int i=0;i<10;i++) {
			while(moderator.arr.get(i)==-99) {try {Thread.sleep(1000);} catch (InterruptedException e) {}} // check whether moderator has generated number or not, if not player sleeps
//			if((READ.has_player_read.get(p_id-1)) == 1) {try {Thread.sleep(4000);} catch (InterruptedException e) {}}
			int z = moderator.arr.get(i);		// Number generated by moderator
			int k=0;
			k = search.linear_search(p_arr, z);		// returns index if true, otherwise -1
//			System.out.println("p_id:" + p_id +" k is:" + k);
			try {Thread.sleep(new Random().nextInt(1000));} catch (InterruptedException e) {}
			if(k>-1){		// if random no. generated by moderator is with player
				scratch_card.add(-100);	// scratch the card
				System.out.println("p_id " + p_id+ " has scratched " + p_arr[k]);
				p_arr[k] = -2;	//value of card changed to keep it scratched
//				System.out.println("p_id:" + p_id +" k is:" + k);
			}
			try {Thread.sleep(new Random().nextInt(1000));} catch (InterruptedException e) {}
			READ.has_player_read.getAndSet(p_id-1, 1);
//			System.out.println("k is " + k);
//			System.out.println("p_id:" + p_id+ " " +Arrays.toString(scratch_card.toArray()));
			try {
			if(scratch_card.get(0)<0 && scratch_card.get(1)<0 && scratch_card.get(2)<0){   // if 3 cards scratched
//				System.out.println(Arrays.toString(scratch_card.toArray()));
				universal.isThereAWinner.set(1);	// There is a winner
				System.out.println("Moderator stopped");
				System.out.println("Numbers generated by moderator: " + moderator.arr.toString());
				System.out.println("Winner is " + p_id);
				System.out.println("Player " + p_id + ": " + Arrays.toString(p_arr));
				System.exit(0);
			}}
			catch(Exception e) {}
			
//			System.out.println("p_id:" + p_id +" "+ READ.has_player_read.toString());
		}
	}
}
//-----
//-----
//-----
//-----


public class game {
	
	public static void main(String[] args) throws Exception{
	    BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
	    System.out.print("Enter no. of players: ");
	    int no_of_players = Integer.parseInt(br.readLine());
	    br.close();
		READ  r = new READ(no_of_players);
		ArrayList<Object> player_objects = new ArrayList<>();
		for(int i=1;i<no_of_players+1;i++) {
			player_objects.add(new player(i));
		}
				
//		moderator mod = moderator.getInstance(); 	
		proxyModerator mod = new proxyModerator();	// Singleton + Proxy Design Pattern
		Thread t1 = new Thread(mod);		// start moderator thread
		t1.start();	
		

		for(int i=0;i<no_of_players; i++) {
			new Thread((Runnable) player_objects.get(i)).start();	// start all player threads
		}
	}
	
}


//-------END